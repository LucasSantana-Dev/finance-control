buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.flywaydb:flyway-core:10.8.1'
        classpath 'org.flywaydb:flyway-database-postgresql:10.8.1'
        classpath 'org.postgresql:postgresql:42.7.3'
    }
}

plugins {
    id 'java'
    id 'org.springframework.boot' version '3.5.3'
    id 'io.spring.dependency-management' version '1.1.6'
    id 'checkstyle'
    id 'pmd'
    id 'com.github.spotbugs' version '6.0.15'
    id 'jacoco'
    id 'org.sonarqube' version '7.0.1.6134'
    id 'org.owasp.dependencycheck' version '10.0.3'
    id 'com.github.ben-manes.versions' version '0.52.0'
}

// Disable configuration cache for now due to buildDir references in closures
// TODO: Update all buildDir references to be configuration cache compatible
tasks.configureEach { task ->
    task.notCompatibleWithConfigurationCache("Build contains buildDir references in closures")
}

group = 'com.finance-control'
version = '0.0.1-SNAPSHOT'
description = 'Finance Control Project'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-cache'
    implementation 'com.github.ben-manes.caffeine:caffeine:3.1.8'
    // Apache HttpClient 5 for RestClient with custom SSL (mTLS)
    implementation 'org.apache.httpcomponents.client5:httpclient5:5.3.1'
    // Redis is optional - only needed for production profile with Redis infrastructure
    compileOnly 'org.springframework.boot:spring-boot-starter-data-redis'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-websocket'
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.postgresql:postgresql'
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.6.0'
    implementation 'me.paulschwarz:spring-dotenv:4.0.0'
    implementation 'org.flywaydb:flyway-core'
    implementation 'org.flywaydb:flyway-database-postgresql'
    implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
    implementation 'org.apache.commons:commons-csv:1.11.0'
    implementation 'com.webcohesion.ofx4j:ofx4j:1.39'
    implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.6'
    implementation 'com.bucket4j:bucket4j-core:8.10.1'
    // bucket4j-redis removed - using in-memory bucket instead
    implementation 'io.sentry:sentry-spring-boot-starter:7.15.0'
    implementation 'io.sentry:sentry-logback:7.15.0'
    implementation 'org.apache.commons:commons-lang3:3.19.0'
    implementation 'jakarta.annotation:jakarta.annotation-api:3.0.0'

    // Supabase Integration - Using RestClient (Spring Boot 3.2+)
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
    testImplementation 'com.h2database:h2'
    testImplementation 'io.projectreactor:reactor-test' // For StepVerifier in reactive tests
    // Apache HttpClient 5 for TestRestTemplate in integration tests
    testImplementation 'org.apache.httpcomponents.client5:httpclient5:5.3.1'
    // TestContainers for PostgreSQL integration tests
    testImplementation 'org.testcontainers:testcontainers:1.19.3'
    testImplementation 'org.testcontainers:postgresql:1.19.3'
    testImplementation 'org.testcontainers:junit-jupiter:1.19.3'
    // Removed: Selenium (replaced with Spring test tools in E2ETest)
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // MapStruct for DTO-Entity mapping (Industry Standard)
    implementation 'org.mapstruct:mapstruct:1.6.2'
    annotationProcessor 'org.mapstruct:mapstruct-processor:1.6.2'

    // SpotBugs security rules via FindSecBugs
    spotbugsPlugins 'com.h3xstream.findsecbugs:findsecbugs-plugin:1.13.0'
    compileOnly 'com.github.spotbugs:spotbugs-annotations:4.8.3'
}

checkstyle {
    toolVersion = '10.16.0'
    configFile = file('checkstyle.xml')
    // Fail build on complexity violations (errors), but allow warnings
    // Complexity violations are set to severity="error" in checkstyle.xml
    ignoreFailures = false
    maxWarnings = 100  // Increased to allow file/method length warnings
}

// Configure Checkstyle task with colored output
tasks.withType(Checkstyle).configureEach {
    reports {
        xml.required = true
        html.required = true
    }

    logging.captureStandardOutput(org.gradle.api.logging.LogLevel.INFO)

    doFirst {
        println "üîç Running Checkstyle..."
    }

    doLast {
        def violations = 0
        try {
            def report = file("${buildDir}/reports/checkstyle/main/checkstyle-report.xml")
            if (report.exists()) {
                def text = report.text
                violations = text.split('<error').length - 1
            }
        } catch (Exception e) {
            // Ignore parsing errors
        }

        if (violations == 0) {
            println "‚úÖ Checkstyle: No violations found"
        } else {
            println "‚ö†Ô∏è  Checkstyle: ${violations} violations found"
        }
    }
}

pmd {
    toolVersion = '7.0.0'
    ruleSetFiles = files('pmd-ruleset.xml')
    // Fail build on high-priority complexity violations (priority 1)
    // Low-priority violations (file/method length) are warnings only
    ignoreFailures = false
    consoleOutput = true
    maxFailures = 0
}

// Configure PMD task with colored output
tasks.withType(Pmd).configureEach {
    reports {
        xml.required = true
        html.required = true
    }

    logging.captureStandardOutput(org.gradle.api.logging.LogLevel.INFO)

    doFirst {
        println "üîç Running PMD..."
    }

    doLast {
        def violations = 0
        try {
            def report = file("${buildDir}/reports/pmd/main.xml")
            if (report.exists()) {
                def text = report.text
                violations = text.split('<violation').length - 1
            }
        } catch (Exception e) {
            // Ignore parsing errors
        }

        if (violations == 0) {
            println "‚úÖ PMD: No violations found"
        } else {
            println "‚ö†Ô∏è  PMD: ${violations} violations found"
        }
    }
}

spotbugs {
    toolVersion = '4.8.3'
    excludeFilter = file('spotbugs-exclude.xml')
    ignoreFailures = true
}

// Configure SpotBugs task with colored output
tasks.withType(com.github.spotbugs.snom.SpotBugsTask).configureEach {
    reports {
        xml.required = true
        html.required = true
    }

    logging.captureStandardOutput(org.gradle.api.logging.LogLevel.INFO)

    doFirst {
        println "üîç Running SpotBugs..."
    }

    doLast {
        def violations = 0
        try {
            def report = file("${buildDir}/reports/spotbugs/main.xml")
            if (report.exists()) {
                def text = report.text
                violations = text.split('<BugInstance').length - 1
            }
        } catch (Exception e) {
            // Ignore parsing errors
        }

        if (violations == 0) {
            println "‚úÖ SpotBugs: No violations found"
        } else {
            println "‚ö†Ô∏è  SpotBugs: ${violations} violations found"
        }
    }
}

test {
    useJUnitPlatform()
    // Removed finalizedBy jacocoTestReport to prevent build failures in Docker
    // jacocoTestReport can be run separately when needed (e.g., in CI)
    enabled = true

    // Detailed test logging
    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        showExceptions true
        showCauses true
        showStackTraces true
        exceptionFormat = 'full'

        // Log test results to file
        afterSuite { desc, result ->
            if (!desc.parent) {
                try {
                    def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successful, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
                    def startItem = '|  ', endItem = '  |'
                    def repeatLength = startItem.length() + output.length() + endItem.length()
                    println('\n' + ('=' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('=' * repeatLength))
                } catch (Exception e) {
                    // Ignore exceptions in afterSuite to prevent test task from failing
                    println("Warning: Failed to log test results summary: ${e.message}")
                }
            }
        }
    }

    // Generate test reports
    reports {
        html.required = true
        junitXml.required = true
    }

    // Modern Gradle test configuration (consolidated above)
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, excludes: [
                '**/FinanceControlApplication.class',
                '**/config/**',
                '**/dto/**',
                '**/model/**',
                '**/exception/**',
                '**/enums/**',
                '**/util/**',
                '**/validation/**'
            ])
        }))
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            element = 'BUNDLE'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.85
            }
        }
        rule {
            element = 'BUNDLE'
            limit {
                counter = 'BRANCH'
                value = 'COVEREDRATIO'
                minimum = 0.85
            }
        }
        rule {
            element = 'BUNDLE'
            limit {
                counter = 'METHOD'
                value = 'COVEREDRATIO'
                minimum = 0.85
            }
        }
        rule {
            element = 'BUNDLE'
            limit {
                counter = 'CLASS'
                value = 'COVEREDRATIO'
                minimum = 0.85
            }
        }
    }
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, excludes: [
                '**/FinanceControlApplication.class',
                '**/config/**',
                '**/dto/**',
                '**/model/**',
                '**/exception/**',
                '**/enums/**',
                '**/util/**',
                '**/validation/**',
                '**/mapper/**',
                '**/repository/**'
            ])
        }))
    }
}

sonarqube {
    properties {
        property "sonar.projectKey", "LucasSantana-Dev_finance-control"
        property "sonar.organization", "lucassantana-dev"
        property "sonar.java.coveragePlugin", "jacoco"
        property "sonar.coverage.jacoco.xmlReportPaths", "${buildDir}/reports/jacoco/test/jacocoTestReport.xml"

        // Cognitive complexity thresholds
        // Production code: max 15, Test code: max 20
        property "sonar.complexity.function.threshold", "15"
        property "sonar.complexity.class.threshold", "20"
        property "sonar.java.cognitive.complexity.threshold", "15"

        // Size thresholds (warnings only, not blocking)
        property "sonar.size.limit.function", "150"
        property "sonar.size.limit.class", "2000"
    }
}

// Configure colored output for all tasks
gradle.startParameter.consoleOutput = org.gradle.api.logging.configuration.ConsoleOutput.Rich

// Configure Java compilation
tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.compilerArgs += ['--enable-preview']

    // Enable colored output for compilation
    logging.captureStandardOutput(org.gradle.api.logging.LogLevel.INFO)
}

// Re-enable test compilation
tasks.withType(JavaCompile).configureEach {
    if (it.name.contains('Test')) {
        enabled = true
    }
}

tasks.withType(Test).configureEach {
    testLogging {
        events "passed", "skipped", "failed"
    }
}


// Task to run all quality checks
task qualityCheck {
    dependsOn checkstyleMain, pmdMain, spotbugsMain, dependencyCheckAnalyze, dependencyUpdates, test, jacocoTestReport, jacocoTestCoverageVerification
    description = 'Runs all code quality checks'

    // Configure colored output
    logging.captureStandardOutput(org.gradle.api.logging.LogLevel.INFO)

    doFirst {
        println "\n${'='*60}"
        println "üöÄ STARTING QUALITY CHECKS"
        println "${'='*60}"
    }

    doLast {
        generateQualityReport()
        println "\n${'='*60}"
        println "‚úÖ QUALITY CHECKS COMPLETED"
        println "${'='*60}"
    }
}

// Task to generate comprehensive quality report
task generateQualityReport {
    description = 'Generates a comprehensive quality report with all violations and test results'

    doLast {
        def reportFile = file("${buildDir}/quality-report.txt")
        reportFile.parentFile.mkdirs()

        def report = new StringBuilder()
        report.append("=" * 80).append("\n")
        report.append("QUALITY REPORT - Finance Control Project\n")
        report.append("Generated: ${new Date()}\n")
        report.append("=" * 80).append("\n\n")

        // Checkstyle violations
        report.append("CHECKSTYLE VIOLATIONS\n")
        report.append("-" * 40).append("\n")
        def checkstyleReport = file("${buildDir}/reports/checkstyle/main/checkstyle-report.xml")
        if (checkstyleReport.exists()) {
            def violations = parseCheckstyleReport(checkstyleReport)
            if (violations.isEmpty()) {
                report.append("‚úì No Checkstyle violations found\n")
            } else {
                violations.each { violation ->
                    report.append("‚úó ${violation.file}:${violation.line} - ${violation.message}\n")
                }
            }
        } else {
            report.append("Checkstyle report not found\n")
        }
        report.append("\n")

        // PMD violations
        report.append("PMD VIOLATIONS\n")
        report.append("-" * 40).append("\n")
        def pmdReport = file("${buildDir}/reports/pmd/main.xml")
        if (pmdReport.exists()) {
            def violations = parsePmdReport(pmdReport)
            if (violations.isEmpty()) {
                report.append("‚úì No PMD violations found\n")
            } else {
                violations.each { violation ->
                    report.append("‚úó ${violation.file}:${violation.line} - ${violation.rule} - ${violation.message}\n")
                }
            }
        } else {
            report.append("PMD report not found\n")
        }
        report.append("\n")

        // SpotBugs violations
        report.append("SPOTBUGS VIOLATIONS\n")
        report.append("-" * 40).append("\n")
        def spotbugsReport = file("${buildDir}/reports/spotbugs/main.xml")
        if (spotbugsReport.exists()) {
            def violations = parseSpotbugsReport(spotbugsReport)
            if (violations.isEmpty()) {
                report.append("‚úì No SpotBugs violations found\n")
            } else {
                violations.each { violation ->
                    report.append("‚úó ${violation.type} - ${violation.message}\n")
                }
            }
        } else {
            report.append("SpotBugs report not found\n")
        }
        report.append("\n")

        // Test results
        report.append("TEST RESULTS\n")
        report.append("-" * 40).append("\n")
        def testResultsFile = file("${buildDir}/test-results/test-results.txt")
        if (testResultsFile.exists()) {
            report.append(testResultsFile.text).append("\n")
        } else {
            report.append("Test results not found\n")
        }

        // JaCoCo coverage
        report.append("COVERAGE RESULTS\n")
        report.append("-" * 40).append("\n")
        def jacocoReport = file("${buildDir}/reports/jacoco/test/jacocoTestReport.xml")
        if (jacocoReport.exists()) {
            def coverage = parseJacocoReport(jacocoReport)
            report.append("Line Coverage: ${coverage.lineCoverage}%\n")
            report.append("Branch Coverage: ${coverage.branchCoverage}%\n")
        } else {
            report.append("JaCoCo report not found\n")
        }

        report.append("\n" + "=" * 80).append("\n")
        report.append("END OF REPORT\n")

        reportFile.text = report.toString()
        println "\nüìä QUALITY REPORT GENERATED"
        println "üìÑ Report location: ${reportFile.absolutePath}"

        // Print summary with colors
        def totalViolations = 0
        def checkstyleViolations = 0
        def pmdViolations = 0
        def spotbugsViolations = 0

        // Count violations
        try {
            def checkstyleReportFile = file("${buildDir}/reports/checkstyle/main/checkstyle-report.xml")
            if (checkstyleReportFile.exists()) {
                def text = checkstyleReportFile.text
                checkstyleViolations = text.split('<error').length - 1
            }
        } catch (Exception e) {}

        try {
            def pmdReportFile = file("${buildDir}/reports/pmd/main.xml")
            if (pmdReportFile.exists()) {
                def text = pmdReportFile.text
                pmdViolations = text.split('<violation').length - 1
            }
        } catch (Exception e) {}

        try {
            def spotbugsReportFile = file("${buildDir}/reports/spotbugs/main.xml")
            if (spotbugsReportFile.exists()) {
                def text = spotbugsReportFile.text
                spotbugsViolations = text.split('<BugInstance').length - 1
            }
        } catch (Exception e) {}

        totalViolations = checkstyleViolations + pmdViolations + spotbugsViolations

        println "\nüîç VIOLATIONS SUMMARY"
        println "${'='*40}"
        println "üîç Checkstyle: ${checkstyleViolations} violations"
        println "üîç PMD: ${pmdViolations} violations"
        println "üîç SpotBugs: ${spotbugsViolations} violations"
        println "${'='*40}"
        println "üìä TOTAL: ${totalViolations} violations"

        if (totalViolations == 0) {
            println "üéâ EXCELLENT! No quality violations found!"
        } else {
            println "‚ö†Ô∏è  Please review and fix the violations above"
        }
    }
}

// Helper methods for parsing reports
def parseCheckstyleReport(File reportFile) {
    def violations = []
    try {
        def text = reportFile.text
        def errorMatches = text.findAll(/<error[^>]*line="([^"]*)"[^>]*message="([^"]*)"[^>]*\/>/) { match, line, message ->
            violations << [
                file: reportFile.name,
                line: line,
                message: message
            ]
        }
    } catch (Exception e) {
        println "Error parsing Checkstyle report: ${e.message}"
    }
    return violations
}

def parsePmdReport(File reportFile) {
    def violations = []
    try {
        def text = reportFile.text
        def violationMatches = text.findAll(/<violation[^>]*beginline="([^"]*)"[^>]*rule="([^"]*)"[^>]*>([^<]*)<\/violation>/) { match, line, rule, message ->
            violations << [
                file: reportFile.name,
                line: line,
                rule: rule,
                message: message
            ]
        }
    } catch (Exception e) {
        println "Error parsing PMD report: ${e.message}"
    }
    return violations
}

def parseSpotbugsReport(File reportFile) {
    def violations = []
    try {
        def text = reportFile.text
        def bugMatches = text.findAll(/<BugInstance[^>]*type="([^"]*)"[^>]*>[\s\S]*?<LongMessage>([^<]*)<\/LongMessage>/) { match, type, message ->
            violations << [
                type: type,
                message: message
            ]
        }
    } catch (Exception e) {
        println "Error parsing SpotBugs report: ${e.message}"
    }
    return violations
}

def parseJacocoReport(File reportFile) {
    def coverage = [lineCoverage: 0, branchCoverage: 0]
    try {
        def text = reportFile.text
        def lineMatch = text.find(/<counter type="LINE" covered="(\d+)" missed="(\d+)"/) { match, covered, missed ->
            def coveredInt = covered.toInteger()
            def missedInt = missed.toInteger()
            def total = coveredInt + missedInt
            coverage.lineCoverage = total > 0 ? Math.round((coveredInt / total) * 100) : 0
        }

        def branchMatch = text.find(/<counter type="BRANCH" covered="(\d+)" missed="(\d+)"/) { match, covered, missed ->
            def coveredInt = covered.toInteger()
            def missedInt = missed.toInteger()
            def total = coveredInt + missedInt
            coverage.branchCoverage = total > 0 ? Math.round((coveredInt / total) * 100) : 0
        }
    } catch (Exception e) {
        println "Error parsing JaCoCo report: ${e.message}"
    }
    return coverage
}


// Docker tasks
task dockerBuild(type: Exec) {
    group = 'docker'
    description = 'Builds the production Docker image'
    workingDir = projectDir
    commandLine = ['docker', 'build', '-t', 'finance-control:latest', '.']
}

task dockerDev(type: Exec) {
    group = 'docker'
    description = 'Starts the Docker development environment'
    workingDir = projectDir
    commandLine = ['docker-compose', '-f', 'docker-compose.dev.yml', 'up', '-d']
}

task dockerProd(type: Exec) {
    group = 'docker'
    description = 'Starts the Docker production environment'
    workingDir = projectDir
    commandLine = ['docker-compose', 'up', '-d']
}

task dockerClean(type: Exec) {
    group = 'docker'
    description = 'Cleans up unused Docker resources'
    workingDir = projectDir
    commandLine = ['docker', 'system', 'prune', '-f']
}

task dockerLogs(type: Exec) {
    group = 'docker'
    description = 'Shows Docker container logs'
    workingDir = projectDir
    commandLine = ['docker-compose', 'logs', '-f']
}

task dockerShell(type: Exec) {
    group = 'docker'
    description = 'Opens a shell in the application container'
    workingDir = projectDir
    commandLine = ['docker-compose', 'exec', 'app', 'bash']
}

task dockerTest(type: Exec) {
    group = 'docker'
    description = 'Runs tests in Docker'
    workingDir = projectDir
    commandLine = ['docker-compose', 'exec', 'app', './gradlew', 'test']

    doFirst {
        def scriptFile = file('gradlew')
        if (!scriptFile.canExecute()) {
            scriptFile.setExecutable(true)
        }
    }
}

// Legacy Maven task removed - project now uses Gradle exclusively



// Configura√ß√£o do Spring Boot
springBoot {
    buildInfo()
}

// SonarQube configuration
sonarqube {
    properties {
        property 'sonar.projectKey', 'LucasSantana-Dev_finance-control'
        property 'sonar.organization', 'lucassantana-dev'
        property 'sonar.projectName', 'Finance Control'
        property 'sonar.projectVersion', version

        // SonarQube Cloud configuration
        // Token is provided via SONAR_TOKEN environment variable (GitHub secret)

        // Source and test directories
        property 'sonar.sources', 'src/main/java'
        property 'sonar.tests', 'src/test/java'

        // Java version
        property 'sonar.java.source', '21'
        property 'sonar.java.target', '21'

        // Encoding
        property 'sonar.sourceEncoding', 'UTF-8'

        // Integration with other tools
        property 'sonar.java.checkstyle.reportPaths', 'build/reports/checkstyle/main.xml'
        property 'sonar.java.pmd.reportPaths', 'build/reports/pmd/main.xml'
        property 'sonar.java.spotbugs.reportPaths', 'build/reports/spotbugs/main.xml'
        property 'sonar.coverage.jacoco.xmlReportPaths', 'build/reports/jacoco/test/jacocoTestReport.xml'

        // Exclusions
        property 'sonar.exclusions', '**/target/**,**/generated/**,**/config/**,**/dto/**,**/model/**,**/exception/**,**/enums/**,**/util/**,**/validation/**'
        property 'sonar.test.exclusions', '**/target/**,**/generated/**'

        // Quality thresholds (cognitive complexity focused)
        // Production code: max 15, Test code: max 20
        property 'sonar.complexity.function.threshold', '15'
        property 'sonar.complexity.class.threshold', '20'
        property 'sonar.java.cognitive.complexity.threshold', '15'
        // Size thresholds (warnings only, not blocking)
        property 'sonar.size.limit.function', '150'
        property 'sonar.size.limit.class', '2000'

        // Coverage thresholds
        property 'sonar.coverage.exclusions', '**/config/**,**/dto/**,**/model/**,**/exception/**,**/enums/**,**/util/**,**/validation/**,**/FinanceControlApplication.java'
        property 'sonar.test.coverage.minimum', '80'

        // Duplicate code
        property 'sonar.cpd.java.minimumTokens', '100'
        property 'sonar.duplicated.lines.density.minimum', '3'
    }
}

// Task to check SonarQube availability
task checkSonarQube {
    description = 'Checks if SonarQube service is running and provides usage instructions'

    doLast {
        def sonarQubeRunning = false
        try {
            def process = "docker-compose --profile sonarqube ps sonarqube".execute()
            process.waitFor()
            def output = process.text
            sonarQubeRunning = output.contains("Up")
        } catch (Exception e) {
            sonarQubeRunning = false
        }

        if (sonarQubeRunning) {
            println "\n‚úÖ SonarQube service is running!"
            println "üåê Access SonarQube at: http://localhost:9000"
            println "üîë Default credentials: admin/admin"
            println "üöÄ To run SonarQube analysis: ./gradlew sonarqube"
            println "üìã Or use the script: ./scripts/dev.sh sonarqube-scan"
        } else {
            println "\n‚ö†Ô∏è  SonarQube service is not running"
            println ""
            println "üìã To start SonarQube:"
            println "   ./scripts/dev.sh sonarqube-start"
            println ""
            println "üìã To run analysis:"
            println "   ./scripts/dev.sh sonarqube-scan"
            println ""
            println "üìã To view logs:"
            println "   ./scripts/dev.sh sonarqube-logs"
        }
    }
}



// ------------------------------
// Security & Dependency scanning configuration
// ------------------------------

dependencyCheck {
    // Update NVD data automatically; consider caching in CI
    autoUpdate = true
    // Fail build only on CRITICAL by default; adjust policy in CI as needed
    failBuildOnCVSS = 9.0
    // Report formats and location
    outputDirectory = file("${buildDir}/reports")
    formats = ["HTML", "JSON"]
    // Optional suppressions file (create if needed)
    if (file('dependency-check-suppressions.xml').exists()) {
        suppressionFile = 'dependency-check-suppressions.xml'
    }

    // NVD API Key configuration (optional but recommended)
    if (System.getenv('NVD_API_KEY')) {
        nvd {
            apiKey = System.getenv('NVD_API_KEY')
            delay = 16000 // 16 seconds between requests to avoid rate limits
        }
    }
}

// Prefer stable versions in dependency updates report
ext.isNonStable = { String version ->
    def v = version?.toLowerCase() ?: ''
    return v.contains('alpha') || v.contains('beta') || v.contains('rc') || v.contains('cr') ||
           v.contains('m') || v.contains('preview') || v.contains('b') || v.contains('ea') ||
           v.endsWith('-snapshot')
}

tasks.named('dependencyUpdates', com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask) {
    checkForGradleUpdate = true
    outputFormatter = 'json,plain,html'
    outputDir = "${buildDir}/reports/dependencyUpdates"
    reportfileName = 'report'
    rejectVersionIf {
        isNonStable(candidate.version) && !isNonStable(currentVersion)
    }
}

// Custom Flyway tasks using Flyway API programmatically
def createFlywayConfig = {
    def useSupabase = System.getenv('SUPABASE_DATABASE_ENABLED') == 'true'
    def url, user, password

    if (useSupabase) {
        def host = System.getenv('SUPABASE_DATABASE_HOST') ?: ''
        def port = System.getenv('SUPABASE_DATABASE_PORT') ?: '5432'
        def database = System.getenv('SUPABASE_DATABASE_NAME') ?: 'postgres'
        def username = System.getenv('SUPABASE_DATABASE_USERNAME') ?: ''
        def dbPassword = System.getenv('SUPABASE_DATABASE_PASSWORD') ?: ''
        def sslMode = System.getenv('SUPABASE_DATABASE_SSL_MODE') ?: 'require'

        url = "jdbc:postgresql://${host}:${port}/${database}?sslmode=${sslMode}"
        user = username
        password = dbPassword
    } else {
        url = System.getenv('DB_URL') ?: 'jdbc:postgresql://localhost:5432/finance_control'
        user = System.getenv('DB_USERNAME') ?: 'postgres'
        password = System.getenv('DB_PASSWORD') ?: 'postgres'
    }

    return [url: url, user: user, password: password]
}

task flywayInfo {
    group = 'flyway'
    description = 'Shows Flyway migration information'

    doLast {
        def config = createFlywayConfig()
        def flyway = org.flywaydb.core.Flyway.configure()
            .dataSource(config.url, config.user, config.password)
            .locations('classpath:db/migration')
            .load()

        def info = flyway.info()
        println "Flyway Migration Info:"
        println "Current version: ${info.current()?.version?.toString() ?: 'None'}"
        println "Pending migrations: ${info.pending().length}"
        info.pending().each { migration ->
            println "  - ${migration.version}: ${migration.description}"
        }
    }
}

task flywayMigrate {
    group = 'flyway'
    description = 'Runs Flyway migrations'

    doLast {
        def config = createFlywayConfig()
        println "Migrating database: ${config.url}"

        def flyway = org.flywaydb.core.Flyway.configure()
            .dataSource(config.url, config.user, config.password)
            .locations('classpath:db/migration')
            .baselineOnMigrate(false)
            .validateOnMigrate(true)
            .outOfOrder(false)
            .cleanDisabled(true)
            .load()

        def result = flyway.migrate()
        println "Migration completed. Migrations applied: ${result.migrationsExecuted}"
        if (result.migrationsExecuted > 0) {
            println "Successfully applied ${result.migrationsExecuted} migration(s)"
        } else {
            println "Database is up to date"
        }
    }
}

task flywayValidate {
    group = 'flyway'
    description = 'Validates Flyway migrations'

    doLast {
        def config = createFlywayConfig()
        def flyway = org.flywaydb.core.Flyway.configure()
            .dataSource(config.url, config.user, config.password)
            .locations('classpath:db/migration')
            .load()

        try {
            flyway.validate()
            println "Validation successful: All migrations are valid"
        } catch (Exception e) {
            throw new GradleException("Validation failed: ${e.message}", e)
        }
    }
}
