plugins {
    id 'java'
    id 'org.springframework.boot' version '3.5.3'
    id 'io.spring.dependency-management' version '1.1.6'
    id 'checkstyle'
    id 'pmd'
    id 'com.github.spotbugs' version '6.0.15'
    id 'jacoco'
    id 'org.sonarqube' version '7.0.1.6134'
    id 'org.owasp.dependencycheck' version '10.0.3'
    id 'com.github.ben-manes.versions' version '0.52.0'
}

group = 'com.finance-control'
version = '0.0.1-SNAPSHOT'
description = 'Finance Control Project'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-data-redis'
    implementation 'org.springframework.boot:spring-boot-starter-cache'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-websocket'
    implementation 'org.postgresql:postgresql'
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.6.0'
    implementation 'me.paulschwarz:spring-dotenv:4.0.0'
    implementation 'org.flywaydb:flyway-core'
    implementation 'org.flywaydb:flyway-database-postgresql'
    implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.6'
    implementation 'com.bucket4j:bucket4j-core:8.10.1'
    implementation 'com.bucket4j:bucket4j-redis:8.10.1'
    implementation 'io.sentry:sentry-spring-boot-starter:7.15.0'
    implementation 'io.sentry:sentry-logback:7.15.0'
    implementation 'org.apache.commons:commons-lang3:3.19.0'
    implementation 'jakarta.annotation:jakarta.annotation-api:3.0.0'
    // Supabase Java client - temporarily commented out until correct coordinates are found
    // implementation 'com.harium:supabase-java:1.0.0'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
    testImplementation 'com.h2database:h2'
    testImplementation 'org.seleniumhq.selenium:selenium-java'
    testImplementation 'org.seleniumhq.selenium:selenium-chrome-driver'
    testImplementation 'org.testcontainers:junit-jupiter'
    testImplementation 'org.testcontainers:postgresql'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // MapStruct for DTO-Entity mapping (Industry Standard)
    implementation 'org.mapstruct:mapstruct:1.6.2'
    annotationProcessor 'org.mapstruct:mapstruct-processor:1.6.2'

    // SpotBugs security rules via FindSecBugs
    spotbugsPlugins 'com.h3xstream.findsecbugs:findsecbugs-plugin:1.13.0'
    compileOnly 'com.github.spotbugs:spotbugs-annotations:4.8.3'
}

checkstyle {
    toolVersion = '10.16.0'
    configFile = file('checkstyle.xml')
    ignoreFailures = true
    maxWarnings = 10
}

// Configure Checkstyle task with colored output
tasks.withType(Checkstyle).configureEach {
    reports {
        xml.required = true
        html.required = true
    }

    logging.captureStandardOutput(org.gradle.api.logging.LogLevel.INFO)

    doFirst {
        println "üîç Running Checkstyle..."
    }

    doLast {
        def violations = 0
        try {
            def report = file("${buildDir}/reports/checkstyle/main/checkstyle-report.xml")
            if (report.exists()) {
                def text = report.text
                violations = text.split('<error').length - 1
            }
        } catch (Exception e) {
            // Ignore parsing errors
        }

        if (violations == 0) {
            println "‚úÖ Checkstyle: No violations found"
        } else {
            println "‚ö†Ô∏è  Checkstyle: ${violations} violations found"
        }
    }
}

pmd {
    toolVersion = '7.0.0'
    ruleSetFiles = files('pmd-ruleset.xml')
    ignoreFailures = true
    consoleOutput = true
    maxFailures = 0
}

// Configure PMD task with colored output
tasks.withType(Pmd).configureEach {
    reports {
        xml.required = true
        html.required = true
    }

    logging.captureStandardOutput(org.gradle.api.logging.LogLevel.INFO)

    doFirst {
        println "üîç Running PMD..."
    }

    doLast {
        def violations = 0
        try {
            def report = file("${buildDir}/reports/pmd/main.xml")
            if (report.exists()) {
                def text = report.text
                violations = text.split('<violation').length - 1
            }
        } catch (Exception e) {
            // Ignore parsing errors
        }

        if (violations == 0) {
            println "‚úÖ PMD: No violations found"
        } else {
            println "‚ö†Ô∏è  PMD: ${violations} violations found"
        }
    }
}

spotbugs {
    toolVersion = '4.8.3'
    excludeFilter = file('spotbugs-exclude.xml')
    ignoreFailures = true
}

// Configure SpotBugs task with colored output
tasks.withType(com.github.spotbugs.snom.SpotBugsTask).configureEach {
    reports {
        xml.required = true
        html.required = true
    }

    logging.captureStandardOutput(org.gradle.api.logging.LogLevel.INFO)

    doFirst {
        println "üîç Running SpotBugs..."
    }

    doLast {
        def violations = 0
        try {
            def report = file("${buildDir}/reports/spotbugs/main.xml")
            if (report.exists()) {
                def text = report.text
                violations = text.split('<BugInstance').length - 1
            }
        } catch (Exception e) {
            // Ignore parsing errors
        }

        if (violations == 0) {
            println "‚úÖ SpotBugs: No violations found"
        } else {
            println "‚ö†Ô∏è  SpotBugs: ${violations} violations found"
        }
    }
}

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
    enabled = true

    // Detailed test logging
    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        showExceptions true
        showCauses true
        showStackTraces true
        exceptionFormat = 'full'

        // Log test results to file
        afterSuite { desc, result ->
            if (!desc.parent) {
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successful, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('=' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('=' * repeatLength))
            }
        }
    }

    // Generate test reports
    reports {
        html.required = true
        junitXml.required = true
    }

    // Modern Gradle test configuration (consolidated above)
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, excludes: [
                '**/FinanceControlApplication.class',
                '**/config/**',
                '**/dto/**',
                '**/model/**',
                '**/exception/**',
                '**/enums/**',
                '**/util/**',
                '**/validation/**'
            ])
        }))
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            element = 'BUNDLE'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.80
            }
        }
        rule {
            element = 'BUNDLE'
            limit {
                counter = 'BRANCH'
                value = 'COVEREDRATIO'
                minimum = 0.80
            }
        }
    }
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, excludes: [
                '**/FinanceControlApplication.class',
                '**/config/**',
                '**/dto/**',
                '**/model/**',
                '**/exception/**',
                '**/enums/**',
                '**/util/**',
                '**/validation/**'
            ])
        }))
    }
}

sonarqube {
    properties {
        property "sonar.projectKey", "LucasSantana-Dev_finance-control"
        property "sonar.organization", "lucassantana-dev"
        property "sonar.java.coveragePlugin", "jacoco"
        property "sonar.coverage.jacoco.xmlReportPaths", "${buildDir}/reports/jacoco/test/jacocoTestReport.xml"
    }
}

// Configure colored output for all tasks
gradle.startParameter.consoleOutput = org.gradle.api.logging.configuration.ConsoleOutput.Rich

// Configure Java compilation
tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.compilerArgs += ['--enable-preview']

    // Enable colored output for compilation
    logging.captureStandardOutput(org.gradle.api.logging.LogLevel.INFO)
}

// Re-enable test compilation
tasks.withType(JavaCompile).configureEach {
    if (it.name.contains('Test')) {
        enabled = true
    }
}

tasks.withType(Test).configureEach {
    testLogging {
        events "passed", "skipped", "failed"
    }
}

// Task to generate quality report without tests
task generateQualityReportNoTests {
    description = 'Generates a quality report without test results and coverage'
    doLast {
        def reportFile = file("${buildDir}/quality-report-no-tests.txt")
        reportFile.parentFile.mkdirs()
        def report = new StringBuilder()
        report.append("=" * 80).append("\n")
        report.append("QUALITY REPORT (NO TESTS) - Finance Control Project\n")
        report.append("Generated: ${new Date()}\n")
        report.append("=" * 80).append("\n\n")
        report.append("CHECKSTYLE VIOLATIONS\n")
        report.append("-" * 40).append("\n")
        def checkstyleReport = file("${buildDir}/reports/checkstyle/main/checkstyle-report.xml")
        if (checkstyleReport.exists()) {
            def violations = parseCheckstyleReport(checkstyleReport)
            if (violations.isEmpty()) {
                report.append("‚úì No Checkstyle violations found\n")
            } else {
                violations.each { violation ->
                    report.append("‚úó ${violation.file}:${violation.line} - ${violation.message}\n")
                }
            }
        } else {
            report.append("Checkstyle report not found\n")
        }
        report.append("\n")
        report.append("PMD VIOLATIONS\n")
        report.append("-" * 40).append("\n")
        def pmdReport = file("${buildDir}/reports/pmd/main.xml")
        if (pmdReport.exists()) {
            def violations = parsePmdReport(pmdReport)
            if (violations.isEmpty()) {
                report.append("‚úì No PMD violations found\n")
            } else {
                violations.each { violation ->
                    report.append("‚úó ${violation.file}:${violation.line} - ${violation.rule} - ${violation.message}\n")
                }
            }
        } else {
            report.append("PMD report not found\n")
        }
        report.append("\n")
        report.append("SPOTBUGS VIOLATIONS\n")
        report.append("-" * 40).append("\n")
        def spotbugsReport = file("${buildDir}/reports/spotbugs/main.xml")
        if (spotbugsReport.exists()) {
            def violations = parseSpotbugsReport(spotbugsReport)
            if (violations.isEmpty()) {
                report.append("‚úì No SpotBugs violations found\n")
            } else {
                violations.each { violation ->
                    report.append("‚úó ${violation.type} - ${violation.message}\n")
                }
            }
        } else {
            report.append("SpotBugs report not found\n")
        }
        report.append("\n")
        report.append("TEST RESULTS\n")
        report.append("-" * 40).append("\n")
        report.append("SKIPPED - Tests were not executed (--no-test flag used)\n")
        report.append("\n")
        report.append("COVERAGE RESULTS\n")
        report.append("-" * 40).append("\n")
        report.append("SKIPPED - Coverage analysis was not executed (--no-test flag used)\n")
        report.append("\n")
        report.append("\n" + "=" * 80).append("\n")
        report.append("END OF REPORT\n")
        reportFile.text = report.toString()
        println "\nüìä QUALITY REPORT GENERATED (NO TESTS)"
        println "üìÑ Report location: ${reportFile.absolutePath}"
        def totalViolations = 0
        def checkstyleViolations = 0
        def pmdViolations = 0
        def spotbugsViolations = 0
        try {
            def checkstyleReportFile = file("${buildDir}/reports/checkstyle/main/checkstyle-report.xml")
            if (checkstyleReportFile.exists()) {
                def text = checkstyleReportFile.text
                checkstyleViolations = text.split('<error').length - 1
            }
        } catch (Exception e) {}
        try {
            def pmdReportFile = file("${buildDir}/reports/pmd/main.xml")
            if (pmdReportFile.exists()) {
                def text = pmdReportFile.text
                pmdViolations = text.split('<violation').length - 1
            }
        } catch (Exception e) {}
        try {
            def spotbugsReportFile = file("${buildDir}/reports/spotbugs/main.xml")
            if (spotbugsReportFile.exists()) {
                def text = spotbugsReportFile.text
                spotbugsViolations = text.split('<BugInstance').length - 1
            }
        } catch (Exception e) {}
        totalViolations = checkstyleViolations + pmdViolations + spotbugsViolations
        println "\nüîç VIOLATIONS SUMMARY"
        println "${'='*40}"
        println "üîç Checkstyle: ${checkstyleViolations} violations"
        println "üîç PMD: ${pmdViolations} violations"
        println "üîç SpotBugs: ${spotbugsViolations} violations"
        println "${'='*40}"
        println "üìä TOTAL: ${totalViolations} violations"
        if (totalViolations == 0) {
            println "üéâ EXCELLENT! No quality violations found!"
        } else {
            println "‚ö†Ô∏è  Please review and fix the violations above"
        }
    }
}

// Task to run quality checks without tests
task qualityCheckNoTests {
    dependsOn checkstyleMain, pmdMain, spotbugsMain, dependencyCheckAnalyze, dependencyUpdates, generateQualityReportNoTests
    description = 'Runs code quality checks without tests'
    // Configure colored output
    logging.captureStandardOutput(org.gradle.api.logging.LogLevel.INFO)
    doFirst {
        println "\n${'='*60}"
        println "üöÄ STARTING QUALITY CHECKS (NO TESTS)"
        println "${'='*60}"
    }
    doLast {
        println "\n${'='*60}"
        println "‚úÖ QUALITY CHECKS COMPLETED (NO TESTS)"
        println "${'='*60}"
    }
}

// Task to run all quality checks
task qualityCheck {
    dependsOn checkstyleMain, pmdMain, spotbugsMain, dependencyCheckAnalyze, dependencyUpdates, test, jacocoTestReport, jacocoTestCoverageVerification
    description = 'Runs all code quality checks'

    // Configure colored output
    logging.captureStandardOutput(org.gradle.api.logging.LogLevel.INFO)

    doFirst {
        println "\n${'='*60}"
        println "üöÄ STARTING QUALITY CHECKS"
        println "${'='*60}"
    }

    doLast {
        generateQualityReport()
        println "\n${'='*60}"
        println "‚úÖ QUALITY CHECKS COMPLETED"
        println "${'='*60}"
    }
}

// Task to generate comprehensive quality report
task generateQualityReport {
    description = 'Generates a comprehensive quality report with all violations and test results'

    doLast {
        def reportFile = file("${buildDir}/quality-report.txt")
        reportFile.parentFile.mkdirs()

        def report = new StringBuilder()
        report.append("=" * 80).append("\n")
        report.append("QUALITY REPORT - Finance Control Project\n")
        report.append("Generated: ${new Date()}\n")
        report.append("=" * 80).append("\n\n")

        // Checkstyle violations
        report.append("CHECKSTYLE VIOLATIONS\n")
        report.append("-" * 40).append("\n")
        def checkstyleReport = file("${buildDir}/reports/checkstyle/main/checkstyle-report.xml")
        if (checkstyleReport.exists()) {
            def violations = parseCheckstyleReport(checkstyleReport)
            if (violations.isEmpty()) {
                report.append("‚úì No Checkstyle violations found\n")
            } else {
                violations.each { violation ->
                    report.append("‚úó ${violation.file}:${violation.line} - ${violation.message}\n")
                }
            }
        } else {
            report.append("Checkstyle report not found\n")
        }
        report.append("\n")

        // PMD violations
        report.append("PMD VIOLATIONS\n")
        report.append("-" * 40).append("\n")
        def pmdReport = file("${buildDir}/reports/pmd/main.xml")
        if (pmdReport.exists()) {
            def violations = parsePmdReport(pmdReport)
            if (violations.isEmpty()) {
                report.append("‚úì No PMD violations found\n")
            } else {
                violations.each { violation ->
                    report.append("‚úó ${violation.file}:${violation.line} - ${violation.rule} - ${violation.message}\n")
                }
            }
        } else {
            report.append("PMD report not found\n")
        }
        report.append("\n")

        // SpotBugs violations
        report.append("SPOTBUGS VIOLATIONS\n")
        report.append("-" * 40).append("\n")
        def spotbugsReport = file("${buildDir}/reports/spotbugs/main.xml")
        if (spotbugsReport.exists()) {
            def violations = parseSpotbugsReport(spotbugsReport)
            if (violations.isEmpty()) {
                report.append("‚úì No SpotBugs violations found\n")
            } else {
                violations.each { violation ->
                    report.append("‚úó ${violation.type} - ${violation.message}\n")
                }
            }
        } else {
            report.append("SpotBugs report not found\n")
        }
        report.append("\n")

        // Test results
        report.append("TEST RESULTS\n")
        report.append("-" * 40).append("\n")
        def testResultsFile = file("${buildDir}/test-results/test-results.txt")
        if (testResultsFile.exists()) {
            report.append(testResultsFile.text).append("\n")
        } else {
            report.append("Test results not found\n")
        }

        // JaCoCo coverage
        report.append("COVERAGE RESULTS\n")
        report.append("-" * 40).append("\n")
        def jacocoReport = file("${buildDir}/reports/jacoco/test/jacocoTestReport.xml")
        if (jacocoReport.exists()) {
            def coverage = parseJacocoReport(jacocoReport)
            report.append("Line Coverage: ${coverage.lineCoverage}%\n")
            report.append("Branch Coverage: ${coverage.branchCoverage}%\n")
        } else {
            report.append("JaCoCo report not found\n")
        }

        report.append("\n" + "=" * 80).append("\n")
        report.append("END OF REPORT\n")

        reportFile.text = report.toString()
        println "\nüìä QUALITY REPORT GENERATED"
        println "üìÑ Report location: ${reportFile.absolutePath}"

        // Print summary with colors
        def totalViolations = 0
        def checkstyleViolations = 0
        def pmdViolations = 0
        def spotbugsViolations = 0

        // Count violations
        try {
            def checkstyleReportFile = file("${buildDir}/reports/checkstyle/main/checkstyle-report.xml")
            if (checkstyleReportFile.exists()) {
                def text = checkstyleReportFile.text
                checkstyleViolations = text.split('<error').length - 1
            }
        } catch (Exception e) {}

        try {
            def pmdReportFile = file("${buildDir}/reports/pmd/main.xml")
            if (pmdReportFile.exists()) {
                def text = pmdReportFile.text
                pmdViolations = text.split('<violation').length - 1
            }
        } catch (Exception e) {}

        try {
            def spotbugsReportFile = file("${buildDir}/reports/spotbugs/main.xml")
            if (spotbugsReportFile.exists()) {
                def text = spotbugsReportFile.text
                spotbugsViolations = text.split('<BugInstance').length - 1
            }
        } catch (Exception e) {}

        totalViolations = checkstyleViolations + pmdViolations + spotbugsViolations

        println "\nüîç VIOLATIONS SUMMARY"
        println "${'='*40}"
        println "üîç Checkstyle: ${checkstyleViolations} violations"
        println "üîç PMD: ${pmdViolations} violations"
        println "üîç SpotBugs: ${spotbugsViolations} violations"
        println "${'='*40}"
        println "üìä TOTAL: ${totalViolations} violations"

        if (totalViolations == 0) {
            println "üéâ EXCELLENT! No quality violations found!"
        } else {
            println "‚ö†Ô∏è  Please review and fix the violations above"
        }
    }
}

// Helper methods for parsing reports
def parseCheckstyleReport(File reportFile) {
    def violations = []
    try {
        def text = reportFile.text
        def errorMatches = text.findAll(/<error[^>]*line="([^"]*)"[^>]*message="([^"]*)"[^>]*\/>/) { match, line, message ->
            violations << [
                file: reportFile.name,
                line: line,
                message: message
            ]
        }
    } catch (Exception e) {
        println "Error parsing Checkstyle report: ${e.message}"
    }
    return violations
}

def parsePmdReport(File reportFile) {
    def violations = []
    try {
        def text = reportFile.text
        def violationMatches = text.findAll(/<violation[^>]*beginline="([^"]*)"[^>]*rule="([^"]*)"[^>]*>([^<]*)<\/violation>/) { match, line, rule, message ->
            violations << [
                file: reportFile.name,
                line: line,
                rule: rule,
                message: message
            ]
        }
    } catch (Exception e) {
        println "Error parsing PMD report: ${e.message}"
    }
    return violations
}

def parseSpotbugsReport(File reportFile) {
    def violations = []
    try {
        def text = reportFile.text
        def bugMatches = text.findAll(/<BugInstance[^>]*type="([^"]*)"[^>]*>[\s\S]*?<LongMessage>([^<]*)<\/LongMessage>/) { match, type, message ->
            violations << [
                type: type,
                message: message
            ]
        }
    } catch (Exception e) {
        println "Error parsing SpotBugs report: ${e.message}"
    }
    return violations
}

def parseJacocoReport(File reportFile) {
    def coverage = [lineCoverage: 0, branchCoverage: 0]
    try {
        def text = reportFile.text
        def lineMatch = text.find(/<counter type="LINE" covered="(\d+)" missed="(\d+)"/) { match, covered, missed ->
            def coveredInt = covered.toInteger()
            def missedInt = missed.toInteger()
            def total = coveredInt + missedInt
            coverage.lineCoverage = total > 0 ? Math.round((coveredInt / total) * 100) : 0
        }

        def branchMatch = text.find(/<counter type="BRANCH" covered="(\d+)" missed="(\d+)"/) { match, covered, missed ->
            def coveredInt = covered.toInteger()
            def missedInt = missed.toInteger()
            def total = coveredInt + missedInt
            coverage.branchCoverage = total > 0 ? Math.round((coveredInt / total) * 100) : 0
        }
    } catch (Exception e) {
        println "Error parsing JaCoCo report: ${e.message}"
    }
    return coverage
}

// Custom tasks to run scripts
task qualityCheckScript(type: Exec) {
    group = 'scripts'
    description = 'Runs quality checks using the bash script'
    workingDir = projectDir
    commandLine = ['bash', 'scripts/quality/quality-check.sh']

    doFirst {
        def scriptFile = file('scripts/quality/quality-check.sh')
        if (!scriptFile.canExecute()) {
            scriptFile.setExecutable(true)
        }
    }
}

task qualityCheckScriptVerbose(type: Exec) {
    group = 'scripts'
    description = 'Runs quality checks with detailed output'
    workingDir = projectDir
    commandLine = ['bash', 'scripts/quality/quality-check.sh', '--verbose']

    doFirst {
        def scriptFile = file('scripts/quality/quality-check.sh')
        if (!scriptFile.canExecute()) {
            scriptFile.setExecutable(true)
        }
    }
}

// Docker tasks
task dockerBuild(type: Exec) {
    group = 'docker'
    description = 'Builds the production Docker image'
    workingDir = projectDir
    commandLine = ['docker', 'build', '-t', 'finance-control:latest', '.']
}

task dockerDev(type: Exec) {
    group = 'docker'
    description = 'Starts the Docker development environment'
    workingDir = projectDir
    commandLine = ['docker-compose', '-f', 'docker-compose.dev.yml', 'up', '-d']
}

task dockerProd(type: Exec) {
    group = 'docker'
    description = 'Starts the Docker production environment'
    workingDir = projectDir
    commandLine = ['docker-compose', 'up', '-d']
}

task dockerClean(type: Exec) {
    group = 'docker'
    description = 'Cleans up unused Docker resources'
    workingDir = projectDir
    commandLine = ['docker', 'system', 'prune', '-f']
}

task dockerLogs(type: Exec) {
    group = 'docker'
    description = 'Shows Docker container logs'
    workingDir = projectDir
    commandLine = ['docker-compose', 'logs', '-f']
}

task dockerShell(type: Exec) {
    group = 'docker'
    description = 'Opens a shell in the application container'
    workingDir = projectDir
    commandLine = ['docker-compose', 'exec', 'app', 'bash']
}

task dockerTest(type: Exec) {
    group = 'docker'
    description = 'Runs tests in Docker'
    workingDir = projectDir
    commandLine = ['docker-compose', 'exec', 'app', './gradlew', 'test']

    doFirst {
        def scriptFile = file('gradlew')
        if (!scriptFile.canExecute()) {
            scriptFile.setExecutable(true)
        }
    }
}

// Legacy Maven task removed - project now uses Gradle exclusively

// Task to run build with detailed logging
task buildWithLogging {
    description = 'Runs the full build with detailed logging saved to file'
    dependsOn clean, qualityCheck

    doFirst {
        def logFile = file("${buildDir}/build.log")
        logFile.parentFile.mkdirs()
        println "Build log will be saved to: ${logFile.absolutePath}"
    }

    doLast {
        def logFile = file("${buildDir}/build.log")
        def summaryFile = file("${buildDir}/build-summary.txt")

        // Create build summary
        summaryFile.text = """
BUILD SUMMARY - Finance Control Project
======================================
Build completed: ${new Date()}
Build directory: ${buildDir.absolutePath}

Generated Reports:
- Quality Report: ${buildDir}/quality-report.txt
- Checkstyle: ${buildDir}/reports/checkstyle/
- PMD: ${buildDir}/reports/pmd/
- SpotBugs: ${buildDir}/reports/spotbugs/
- Tests: ${buildDir}/reports/tests/
- JaCoCo: ${buildDir}/reports/jacoco/

Log Files:
- Build Log: ${buildDir}/build.log
- Test Results: ${buildDir}/test-results/test-results.txt
- Quality Report: ${buildDir}/quality-report.txt

To view the quality report: cat ${buildDir}/quality-report.txt
To view test results: cat ${buildDir}/test-results/test-results.txt
To view build log: cat ${buildDir}/build.log
        """.trim()

        println "Build summary saved to: ${summaryFile.absolutePath}"
    }
}

// Configure all tasks to log to file
allprojects {
    tasks.withType(JavaCompile).configureEach {
        doFirst {
            def logFile = file("${buildDir}/logs/compile.log")
            logFile.parentFile.mkdirs()
            println "Compilation log will be saved to: ${logFile.absolutePath}"
        }
    }

    tasks.withType(Test).configureEach {
        doFirst {
            def logFile = file("${buildDir}/logs/test.log")
            logFile.parentFile.mkdirs()
            println "Test log will be saved to: ${logFile.absolutePath}"
        }
    }

    tasks.withType(Checkstyle).configureEach {
        doFirst {
            def logFile = file("${buildDir}/logs/checkstyle.log")
            logFile.parentFile.mkdirs()
            println "Checkstyle log will be saved to: ${logFile.absolutePath}"
        }
    }

    tasks.withType(Pmd).configureEach {
        doFirst {
            def logFile = file("${buildDir}/logs/pmd.log")
            logFile.parentFile.mkdirs()
            println "PMD log will be saved to: ${logFile.absolutePath}"
        }
    }
}

// Task to show quality violations summary
task showViolations {
    description = 'Shows a summary of all quality violations'

    doLast {
        def qualityReport = file("${buildDir}/quality-report.txt")
        if (qualityReport.exists()) {
            println "\nüîç QUALITY VIOLATIONS SUMMARY"
            println "${'='*50}"

            def violationCount = 0
            qualityReport.eachLine { line ->
                if (line.startsWith("‚úó")) {
                    println "‚ùå ${line.substring(1)}"
                    violationCount++
                }
            }

            println "${'='*50}"
            println "üìä Total violations found: ${violationCount}"

            if (violationCount == 0) {
                println "üéâ No violations found!"
            } else {
                println "‚ö†Ô∏è  Please fix these violations to improve code quality"
            }
        } else {
            println "‚ùå Quality report not found. Run 'qualityCheck' task first."
        }
    }
}

// Task to demonstrate colored output
task demoColors {
    description = 'Demonstrates colored output capabilities'

    doLast {
        println "\nüé® COLORED OUTPUT DEMONSTRATION"
        println "${'='*50}"
        println "üîç Checkstyle: 5 violations found"
        println "üîç PMD: 12 violations found"
        println "üîç SpotBugs: 3 violations found"
        println "üß™ Tests: 25 passed, 2 failed, 1 skipped"
        println "üìä Coverage: 85% line, 78% branch"
        println "${'='*50}"
        println "‚úÖ Success indicators"
        println "‚ùå Error indicators"
        println "‚ö†Ô∏è  Warning indicators"
        println "üîç Analysis indicators"
        println "üìä Report indicators"
        println "üéâ Celebration indicators"
    }
}

// Configura√ß√£o do Spring Boot
springBoot {
    buildInfo()
}

// SonarQube configuration
sonarqube {
    properties {
        property 'sonar.projectKey', 'LucasSantana-Dev_finance-control'
        property 'sonar.organization', 'lucassantana-dev'
        property 'sonar.projectName', 'Finance Control'
        property 'sonar.projectVersion', version

        // SonarQube Cloud configuration
        // Token is provided via SONAR_TOKEN environment variable (GitHub secret)

        // Source and test directories
        property 'sonar.sources', 'src/main/java'
        property 'sonar.tests', 'src/test/java'

        // Java version
        property 'sonar.java.source', '21'
        property 'sonar.java.target', '21'

        // Encoding
        property 'sonar.sourceEncoding', 'UTF-8'

        // Integration with other tools
        property 'sonar.java.checkstyle.reportPaths', 'build/reports/checkstyle/main.xml'
        property 'sonar.java.pmd.reportPaths', 'build/reports/pmd/main.xml'
        property 'sonar.java.spotbugs.reportPaths', 'build/reports/spotbugs/main.xml'
        property 'sonar.coverage.jacoco.xmlReportPaths', 'build/reports/jacoco/test/jacocoTestReport.xml'

        // Exclusions
        property 'sonar.exclusions', '**/target/**,**/generated/**,**/config/**,**/dto/**,**/model/**,**/exception/**,**/enums/**,**/util/**,**/validation/**'
        property 'sonar.test.exclusions', '**/target/**,**/generated/**'

        // Quality thresholds
        property 'sonar.complexity.function.threshold', '10'
        property 'sonar.size.limit.function', '150'
        property 'sonar.size.limit.class', '2000'

        // Coverage thresholds
        property 'sonar.coverage.exclusions', '**/config/**,**/dto/**,**/model/**,**/exception/**,**/enums/**,**/util/**,**/validation/**,**/FinanceControlApplication.java'
        property 'sonar.test.coverage.minimum', '80'

        // Duplicate code
        property 'sonar.cpd.java.minimumTokens', '100'
        property 'sonar.duplicated.lines.density.minimum', '3'
    }
}

// Task to check SonarQube availability
task checkSonarQube {
    description = 'Checks if SonarQube service is running and provides usage instructions'

    doLast {
        def sonarQubeRunning = false
        try {
            def process = "docker-compose --profile sonarqube ps sonarqube".execute()
            process.waitFor()
            def output = process.text
            sonarQubeRunning = output.contains("Up")
        } catch (Exception e) {
            sonarQubeRunning = false
        }

        if (sonarQubeRunning) {
            println "\n‚úÖ SonarQube service is running!"
            println "üåê Access SonarQube at: http://localhost:9000"
            println "üîë Default credentials: admin/admin"
            println "üöÄ To run SonarQube analysis: ./gradlew sonarqube"
            println "üìã Or use the script: ./scripts/dev.sh sonarqube-scan"
        } else {
            println "\n‚ö†Ô∏è  SonarQube service is not running"
            println ""
            println "üìã To start SonarQube:"
            println "   ./scripts/dev.sh sonarqube-start"
            println ""
            println "üìã To run analysis:"
            println "   ./scripts/dev.sh sonarqube-scan"
            println ""
            println "üìã To view logs:"
            println "   ./scripts/dev.sh sonarqube-logs"
        }
    }
}



// ------------------------------
// Security & Dependency scanning configuration
// ------------------------------

dependencyCheck {
    // Update NVD data automatically; consider caching in CI
    autoUpdate = true
    // Fail build only on CRITICAL by default; adjust policy in CI as needed
    failBuildOnCVSS = 9.0
    // Report formats and location
    outputDirectory = file("${buildDir}/reports")
    formats = ["HTML", "JSON"]
    // Optional suppressions file (create if needed)
    if (file('dependency-check-suppressions.xml').exists()) {
        suppressionFile = 'dependency-check-suppressions.xml'
    }

    // NVD API Key configuration (optional but recommended)
    if (System.getenv('NVD_API_KEY')) {
        nvd {
            apiKey = System.getenv('NVD_API_KEY')
            delay = 16000 // 16 seconds between requests to avoid rate limits
        }
    }
}

// Prefer stable versions in dependency updates report
ext.isNonStable = { String version ->
    def v = version?.toLowerCase() ?: ''
    return v.contains('alpha') || v.contains('beta') || v.contains('rc') || v.contains('cr') ||
           v.contains('m') || v.contains('preview') || v.contains('b') || v.contains('ea') ||
           v.endsWith('-snapshot')
}

tasks.named('dependencyUpdates', com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask) {
    checkForGradleUpdate = true
    outputFormatter = 'json,plain,html'
    outputDir = "${buildDir}/reports/dependencyUpdates"
    reportfileName = 'report'
    rejectVersionIf {
        isNonStable(candidate.version) && !isNonStable(currentVersion)
    }
}
